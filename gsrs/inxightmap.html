<html>
<head>
<style>
body{
  font-family:sans-serif;
}
.scriptlist{
	padding:10px;
	width:40%;
	display:inline-block;
}
.scriptlist select{
	width:100%;
}
.scriptdetails{
	padding:10px;
	width:40%;
	display:inline-block;
	vertical-align: top; /* here */
}
.required{
color:#ff0000;
}
.template{
  display:none;
}
.argument textarea{
  width:100%;
}
.argument {
    display: inline-block;
    width: 33%;
    padding: 10px;
}
.data {
  width: 40%;
  display: inline-block;
  padding: 10px;
}
.checkop {
  width: 30%;
  display: inline-block;
}
.data textarea {
  width: 100%;
  min-height: 300px;
  white-space: nowrap;
}
.buttons {
  width: 8%;
  display: inline-block;
  
    vertical-align: top;
    margin-top: 100px;
}
.buttons button{
  width:100%;
}
.description{
  padding:20px;
}
h1{
  font-weight:bold;
}

h3{
  padding:10px;
  width:100%;
  border-bottom: 1px solid black;
  font-weight:bold;
}
</style>
</head>
<body>
<script
  src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
  integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs="
  crossorigin="anonymous"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.0.0/lodash.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fast-json-patch/1.0.1/json-patch.min.js"></script>

<div>
<h3>
GSRS API Demo
</h3>
<div class="description">
Enter substance names or codes to resolve on the left, select what you'd like to map to below, and click "Map" to resolve the output using GSRS. Results are tab-delimited.
</div>

<label for="apikey">API Key</label>
<input id="apikey" />
<div class="manual">
  <span class="data">
<h1>
Input
</h1>
<textarea id="input">
SUBOXONE
NATURETIN
CELESTONE
203120-17-6
20305-51-5
NPL-2009
DD-3480
SM-1213
</textarea>
</span>
  <div class="buttons">
    <button onclick="resolve()">
      Map ->
    </button>
    <button onclick="sortResults()">
      (Sort)
    </button>
  </div>
  <span class="data">
<h1>
Output
</h1>
<textarea id="output"></textarea>
</span>
</div>
  <form id="outputSettings">
  </form>
</div>
<div id="showScripts">
	<div class="scriptlist">
		<select id="scriptlist" size="10">
		</select>
	</div>
	<div id="scriptdetails" class="scriptdetails">
	</div>
</div>
<div>
  <form id="scriptArguments">
    
  </form>
</div>
<div class="template" id="argTemplate">
    <div class="argument">
    <div>
      <label for="$arg$">$arg$</label><span class="required" title="required">$req$</span>
    </div>
    <div>
      <textarea id="$arg$" name="$arg$">$value$</textarea>
    </div>
    </div>
</div>
<div class="template" id="fetcherTemplate">
    <div class='checkop'>
      <input type="checkbox" name="$name$" id="$name$">
      <label for="$name$">$name$</label>
    </div>
</div>
<textarea id="console">
</textarea>
<!-- SHIM for ie<=9 -->
<script>
  if (!window.JSON) {
  window.JSON = {
    parse: function(sJSON) { return eval('(' + sJSON + ')'); },
    stringify: (function () {
      var toString = Object.prototype.toString;
      var isArray = Array.isArray || function (a) { return toString.call(a) === '[object Array]'; };
      var escMap = {'"': '\\"', '\\': '\\\\', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t'};
      var escFunc = function (m) { return escMap[m] || '\\u' + (m.charCodeAt(0) + 0x10000).toString(16).substr(1); };
      var escRE = /[\\"\u0000-\u001F\u2028\u2029]/g;
      return function stringify(value) {
        if (value == null) {
          return 'null';
        } else if (typeof value === 'number') {
          return isFinite(value) ? value.toString() : 'null';
        } else if (typeof value === 'boolean') {
          return value.toString();
        } else if (typeof value === 'object') {
          if (typeof value.toJSON === 'function') {
            return stringify(value.toJSON());
          } else if (isArray(value)) {
            var res = '[';
            for (var i = 0; i < value.length; i++)
              res += (i ? ', ' : '') + stringify(value[i]);
            return res + ']';
          } else if (toString.call(value) === '[object Object]') {
            var tmp = [];
            for (var k in value) {
              if (value.hasOwnProperty(k))
                tmp.push(stringify(k) + ': ' + stringify(value[k]));
            }
            return '{' + tmp.join(', ') + '}';
          }
        }
        return '"' + value.toString().replace(escRE, escFunc) + '"';
      };
    })()
  };
}




//This is a simple method to turn JSON to JSONP
//via another web service
function getJson(url, cb){
  $.getJSON("https://json2jsonp.com/?url=" + url + "&callback=?",function(json){
   cb(json);
  });
};


function sortResults(){
  var names=$("#input").val().split("\n");
  var namesres=$("#output").val().split("\n");
  
  var order={};
  var i=0;
  names.map(function(nm){
   if(!order[nm]){
      order[nm]=[i++];
   }else{
      order[nm].push(i++);
   }
  });
  
  var sorted=_.chain(namesres)
   .map(function(nn){
    var ord=999999;
    var nm=nn.split("\t")[0];
    if(order[nm]){
    	if(order[nm].length>0){
         ord=order[nm].pop();
      }
    }
   	return {
    				result:nn, 
            order:ord
            };
   })
   .value()
   .sort(function(n1,n2){
   		return n1.order-n2.order;
   })
   .map(function(o){
   		return o.result;
   });
  
  
  $("#output").val(sorted.join("\n"));
  
}

function resolve(){
$("#output").html("");
  var csize=10;
  var names=$("#input").val().split("\n");
  var b_names=_.chunk(names, csize);
  var i=0;
  
  var next=function(){
  	if(i>=b_names.length)return;
    ResolveWorker.builder()
               .list(b_names[i])
               .fetchers(_.map($('div.checkop input:checked'), 'name'))
               .consumer(function(row){$("#output").append(row+ "\n")})
               .finisher(function(){i++;next();})
               .resolve();
  };
	
  next();
	
	//console.log(d);
}






var GSRSAPI={
    builder: function(){
        var g_api={};
        g_api.GlobalSettings = {
          _url:"https://drugs.ncats.io/ginas/app/api/v1/",
          getBaseURL: function() {
            return g_api.GlobalSettings._url;
          },
	  setBaseURL: function(url) {
            g_api.GlobalSettings._url=url;
            return g_api.GlobalSettings;
          },
          getHomeURL: function() {
            return g_api.GlobalSettings.getBaseURL().replace(/api.v1.*/g,"");
          },
          httpType: function() {
            //return "jsonp"; //get only
            return "jsonP"; //CORS needed, updates possible 
          },
          authenticate: function(req){
            req.headers={};
            //push token header for now
            //req.headers["auth-token"]="d012ef187d53138c8e515717ba4243830335a935";
          }
        };

        //TODO: should be its own service
        g_api.httpProcess=function (req) {
          return g_api.JPromise.of(function(cb) {
            var b = req._b;
            if (b) {
              b = JSON.stringify(b);
            } else {
              b = req._q;
            }
            if (req._url.match(/.*[?]/)) {
              req._url = req._url + "&cache=" + g_api.UUID.randomUUID();
            } else {
              req._url = req._url + "?cache=" + g_api.UUID.randomUUID();
            }
            g_api.GlobalSettings.authenticate(req);
	    			console.log(b);
            console.log("called:" + req._url);
            $.ajax({
              url: req._url,
              jsonp: "callback",
              dataType: GlobalSettings.httpType(),
              contentType: 'application/json',
              type: req._method,
              data: b,
              beforeSend: function(request) {
                if(req.headers){
                    _.forEach(_.keys(req.headers), function(k){
                                            request.setRequestHeader(k, req.headers[k]);                    
                                        });
                }
              },
              success: function(response) {
                cb(response);
              },
              error: function(rep, error, t) {
                console.log(error + "\t" + t);
                cb(""); //for now
              }
            });
          });
        };
        //Returns an object which will call
        //the supplied callback after {{total}}
        //number of calls to {{decrement}}
        g_api.getListener = function(total, cb) {
          return {
            total: total,
            current: 0,
            callback: cb,
            decrement: function() {
              this.current++;
              if (this.current >= this.total) {
                this.callback();
              }
            }
          };
        }


        g_api.JPromise = {
              ofScalar: function(s) {
                return g_api.JPromise.of(function(cb) {
                  cb(s);
                });
              },
              of: function(calc) {
                var ret = {
                  get: function(cb) {
                    calc(cb);
                  },
                  andThen: function(lam) {
                    return g_api.JPromise.of(function(cb) {
                      ret.get(function(orig) {
                        var ret = lam(orig);
                        if (ret && ret._promise) {
                          ret.get(cb);
                        } else if(typeof ret === "undefined"){
                          cb(orig);
                        } else{
                          cb(ret);
                        }
                      });
                    });
                  },
                  _promise: true
                };
                return ret;
              },
              join: function(listo) {
                var list = [];
                if (arguments.length > 1) {
                  list = arguments;
                } else {
                  list = listo;
                }
                return g_api.JPromise.of(function(cb) {
                  var toRet = {};
                  var retFun = function() {
                    var retList = [];
                    for (var j = 0; j < list.length; j++) {
                      retList.push(toRet[j]);
                    }
                    return retList;
                  };
                  var listener = g_api.getListener(list.length, function() {
                    cb(retFun());
                  });
                  var proc = function(pFetch, key) {
                    pFetch.get(function(ret) {
                      toRet[key] = ret;
                      listener.decrement();
                    });
                  };
                  for (var i = 0; i < list.length; i++) {
                    var pFetch = list[i];
                    proc(pFetch, i);
                  }
                });
              }
            };

        g_api.gUtil = {
          null: {},
          deepIterate: function(o, path, cb) {
            if (_.isFunction(o)) {
              return g_api.gUtil.null;
            } else if (_.isObject(o)) {
              if (_.isArray(o)) {
                var ks = _.keys(o);
                _.forEach(ks, function(k) {
                  g_api.gUtil.deepIterate(o[k], path + "[" + k + "]", cb);
                });
              } else {
                var ks = _.keys(o);
                _.forEach(ks, function(k) {
                  g_api.gUtil.deepIterate(o[k], path + "/" + k, cb);
                });
              }
            } else {
              cb(path, o);
            }
          },
          forEachDeep: function(o, path, cb) {
            var node = function(path, key, value, parent) {
              return {
                path: path,
                key: key,
                value: value,
                parent: parent
              };
            };
            if (_.isFunction(o)) {
              return g_api.gUtil.null;
            } else if (_.isObject(o)) {
              if (_.isArray(o)) {
                var ks = _.keys(o);
                var mod = false;
                _.forEach(ks, function(k) {
                  var rep = cb(node(path, k, o[k], o));
                  if (rep == g_api.gUtil.null) {
                    o[k] = g_api.gUtil.null;
                    mod = true;
                  } else {
                    if (typeof rep !== "undefined") {
                      o[k] = rep;
                    }
                    g_api.gUtil.forEachDeep(o[k], path + "/" + k, cb);
                  };
                });
                if (mod) {
                  var newArray = _.filter(o, function(e) {
                    if (e == g_api.gUtil.null) return false;
                    return true
                  });
                  o.splice(0, o.length);
                  _.forEach(newArray, function(a) {
                    o.push(a);
                  });
                }
              } else {
                var ks = _.keys(o);
                _.forEach(ks, function(k) {
                  var rep = cb(node(path, k, o[k], o));
                  if (rep === gUtil.null) {
                    delete o[k];
                  } else {
                    if (typeof rep !== "undefined") {
                      o[k] = rep;
                    }
                    g_api.gUtil.forEachDeep(o[k], path + "/" + k, cb);
                  }
                });
              }
            }
          },
          removeDeep: function(o, test) {
            g_api.gUtil.forEachDeep(o, "", function(node) {
              if (test(node)) {
                return gUtil.null;
              }
            });
          },
          removeKeysLike: function(o, regex) {
            g_api.gUtil.removeDeep(o, function(node) {
              return node.key.match(regex);
            });
          },
          toDate: function(d){
            return new Date(d);
          }
        };

	//This is the basic structure for finding things from the API        
        g_api.ResourceFinder = {
            builder: function(){
                var finder = {};
                finder.resource=function(resource){
                    finder.resource=resource;
                    return finder;
                };
                finder.searcher=function(){
                    return g_api.SearchRequest
                                 .builder()
                                 .resource(finder.resource);
                };
                finder.search = function(q){
                    return finder.searcher()
                                 .query(q)
                                 .execute();
                };

                finder.get = function(uuid){
                    var req = g_api.Request.builder()
                                     .url(g_api.GlobalSettings.getBaseURL() + finder.resource + "(" + uuid + ")");
                    
                    return g_api.httpProcess(req).andThen(function(sim) {
                           //TODO: make generic
                           return g_api.SubstanceBuilder.fromSimple(sim);
                    });
                };

                finder.extend = function(f){
                  var nfinder= f(finder);
                  if(typeof nfinder !== "undefined"){
                    return nfinder;
                  }else{
                    return finder;
                  }
                };

                return finder;
            }
        };

        g_api.SubstanceFinder = g_api.ResourceFinder.builder()
                                      .resource("substances")
                                      .extend(function(sfinder){
                                        sfinder.searchByExactNameOrCode = function(q) {
                                            if(UUID.isUUID(q)){
                                                return sfinder.get(q).andThen(function(s){return {"content": [s]}});
                                            }
                                            return sfinder.search("root_names_name:\"^" + q + "$\" OR " +
                                              "root_approvalID:\"^" + q + "$\" OR " +
                                              "root_codes_code:\"^" + q + "$\"");
                                          };
                                        sfinder.getExactStructureMatches = function(smi) {
                                          //substances/structureSearch?q=CCOC(N)=O&type=exact
                                            var req = g_api.Request.builder()
                                                             .url(g_api.GlobalSettings.getBaseURL() + "substances/structureSearch")
                                                             .queryStringData({
                                                                    q:smi,
                                                                    type:"exact",
                                                                    sync:"true" //shouldn't be sync
                                                                });      
                                            return g_api.httpProcess(req).andThen(function(tmp) {
                                              return tmp;
                                            });
                                          };
                                        sfinder.getDisplayNameMatches = function(q) {
                                          return sfinder.search("root_Display Name:\"^" + q + "$\"");
                                          };

                                      });
        g_api.ReferenceFinder = g_api.ResourceFinder.builder()
              .resource("references")
              .extend(function(rfinder){
                  rfinder.searchByLastEdited = function(q) {
                       return rfinder.search("root_lastEditedBy:\"^" + q + "$\"");
                    };
              });

        g_api.CVFinder = g_api.ResourceFinder.builder()
              .resource("vocabularies")
              .extend(function(cvfinder){
                  cvfinder.searchByDomain = function(q) {
                       return cvfinder.search("root_domain:\"^" + q + "$\"");
                    };
              });

        g_api.SearchRequest = {
            builder: function(){
                var request = {
                       _limit:10,
                       _skip:0,
                       _resource:"resource",
                       _query:""
                    };   
                request.limit = function(limit){
                    request._limit=limit;
                    return request;
                };
                request.skip = function(skip){
                    request._skip=skip;
                    return request;
                };
                request.top = function(top){
                    return request.limit(top);
                };
                request.resource = function(resource){
                    request._resource=resource;
                    return request;
                };
                request.query = function(q){
                    request._query=q;
                    return request;
                };
                request.asRequest = function(){
                    return g_api.Request.builder()
                           .url(g_api.GlobalSettings.getBaseURL() + request._resource + "/search")
                           .queryStringData({
                                q: request._query,
                                top: request._limit,
                                skip: request._skip
                           });
                };
                request.execute = function(){
                    return request.asRequest().execute();
                };
                return request;
            }
        };


        //TODO
        g_api.SearchResponse = {
            builder: function(){
                var resp ={};
                resp.mix= function(raw){
                    _.merge(resp, raw);
                    return resp;
                };
                return resp;
            }
        };

        g_api.SubstanceBuilder = {
          fromSimple: function(simple) {
            simple._cache = {};
            simple.getBestID = function() {
              if (simple._approvalIDDisplay) {
                return simple._approvalIDDisplay;
              } else {
                return simple.uuid;
              }
            };
            simple.full = function() {
              var req = Request.builder()
                .url(g_api.GlobalSettings.getBaseURL() + "substances(" + simple.uuid + ")")
                .queryStringData({
                  view: "full"
                });
              return req.execute();
            };
            simple.fetch = function(field, lambda) {
              var ret = simple._cache[field];
              var p = null;
              if (!ret) {
                var url = g_api.GlobalSettings.getBaseURL() + "substances(" + simple.uuid + ")/";
                if (field) {
                  url += field;
                }
                var req = g_api.Request.builder()
                  .url(url);
                p = g_api.httpProcess(req);
              } else {
                p = g_api.JPromise.ofScalar(ret);
              }
              if (lambda) {
                return p.andThen(lambda);
              }
              return p;
            };
            simple.patch = function() {
              var p = Patch.builder();
              p._oldApply = p.apply;
              p._oldCompute = p.compute;
              p._oldValidate = p.validate;
              p.apply = function() {
                return p._oldApply(simple);
              };
              p.compute = function() {
                return p._oldCompute(simple);
              };
              p.validate = function() {
                return p._oldValidate(simple);
              };
              return p;
            };
            return simple;
          }
        };

        g_api.Patch = {
          builder: function() {
            var b = {
              ops: []
            };
            b.change = function(op) {
              b.ops.push(op);
              return b;
            };
            b.replace = function(path, n) {
              return b.change({
                op: "replace",
                path: path,
                value: n
              });
            };
            b.add = function(path, n) {
              return b.change({
                op: "add",
                path: path,
                value: n
              });
            };

            b.addData = function(data) {
              return data.addToPatch(b);
            };

            //should return a promise
            b.apply = function(simpleSub) {
              return simpleSub.full()
                .andThen(function(ret) {
                  var rr = ret;
                  jsonpatch.apply(rr, b.ops);
                  var req = g_api.Request.builder()
                    .url(g_api.GlobalSettings.getBaseURL() + "substances")
                    .method("PUT")
                    .body(rr);

                  return g_api.httpProcess(req);
                });
            };

            //Calculates the new record, does not submit it
            b.compute = function(simpleSub) {
              return simpleSub.full()
                .andThen(function(ret) {
                  var rr = ret;
                  jsonpatch.apply(rr, b.ops);
                  return rr;
                });
            };

            //Calculates the new record, does not submit it
            b.validate = function(simpleSub) {
              return simpleSub.full()
                .andThen(function(ret) {
                  var rr = ret;
                  jsonpatch.apply(rr, b.ops);
                  var req = g_api.Request.builder()
                    .url(g_api.GlobalSettings.getBaseURL() + "substances/@validate")
                    .method("POST")
                    .body(rr);
                  return g_api.httpProcess(req);
                });
            };
            return b;
          }
        };

        g_api.ResolveWorker = {
          builder: function() {
            var worker = {
              _list: [],
              _fetchers: [],
              _consumer: function(r) {},
              _finisher: function() {},
              consumer: function(c) {
                worker._consumer = c;
                return worker;
              },
              list: function(l) {
                worker._list = l;
                return worker;
              },
              fetchers: function(f) {
                worker._fetchers = f;
                return worker;
              },
              finisher: function(f) {
                worker._finisher = f;
                return worker;
              },
              resolve: function() {
                var psubs = _.chain(worker._list)
                  .filter(function(r) {
                    return (r.length > 0);
                  })
                  .map(function(r) {
                    var pSub = g_api.SubstanceFinder.searchByExactNameOrCode(r);
                    pSub._q = r;
                    return pSub;
                  })
                  .value();

                var listener = getListener(psubs.length, function() {
                  worker._finisher();
                });

                _.forEach(psubs, function(pSub) {
                  worker.process(pSub, worker._fetchers).get(function(rows) {
                    _.forEach(rows, function(row) {
                      worker._consumer(row);
                    });
                    listener.decrement();
                  });
                });
              },
	      process: function(pSub, fetchNames) {
		  var row = pSub._q;
		  return pSub.andThen(function(ret) {
		      return ret["content"];
		    })
		    .andThen(function(content) {
		      if (content && content.length > 0) {
			var promises = _.map(content, function(c) {
			  return worker.outputAll(g_api.SubstanceBuilder.fromSimple(c), fetchNames);
			});
			return g_api.JPromise.join(promises).andThen(function(all) {
			  return _.map(all, function(q) {
			    return row + "\t" + q;
			  });
			});
		      } else {
			return g_api.JPromise.ofScalar([row]);
		      }
		    });
	      },
		outputAll: function(simpleSub, fetchNames) {
		  return g_api.JPromise.of(function(cb) {
		    g_api.FetcherRegistry.getFetchers(fetchNames)
		      .fetcher(simpleSub)
		      .get(function(g) {
			cb(g.join("\t"));
		      });
		  });
		}
            };
            return worker;
          }
        };


        //TODO: convert to builder pattern
        g_api.FetcherMaker = {
          make: function(name, maker) {
            var fetcher = {
              name: name,
              tags:[],
              fetcher: function(simp) {
		return g_api.JPromise.of(function(cb){
			maker(simp).get(function(ret){
				cb(ret,name);
			});
		});
              },
              andThen: function(after) {
                return g_api.FetcherMaker.make(name, function(simp){
                    return fetcher.fetcher(simp).andThen(after);
                });
              }
            };
            fetcher.addTag = function (tag){
                fetcher.tags.push(tag);
                return fetcher;
            };
            fetcher.setDescription = function (desc){
                fetcher.description = desc;
                return fetcher;
            };
            return fetcher;
          },
          makeAPIFetcher: function(property, name) {
            var nm = name;
            if (!nm) {
              nm = property;
            }
            return g_api.FetcherMaker.make(nm, function(simpleSub) {
              return simpleSub.fetch(property);
            });
          },  
          makeScalarFetcher: function(property, name) {
            var nm = name;
            if (!nm) {
              nm = property;
            }
            return g_api.FetcherMaker.make(nm, function(simpleSub) {
              return g_api.JPromise.ofScalar(simpleSub[property]);
            });
          },
          makeCodeFetcher: function(codeSystem, name) {
            var nm = name;
            if (!nm) {
              nm = codeSystem + "[CODE]"
            }
            return g_api.FetcherMaker.make(nm, function(simpleSub) {
              return simpleSub.fetch("codes(codeSystem:" + codeSystem + ")")
                .andThen(function(cds) {
                  return _.chain(cds)
                          .sort(function(a,b){
                                if(a.type==="PRIMARY" && b.type!=="PRIMARY") {
                                        return -1;
                                }else if(a.type!=="PRIMARY" && b.type==="PRIMARY") {
                                        return 1
                                }else{
                                        return 0;
                                }
                          })
                          .map(function(cd) {
                                if (cd.type !== "PRIMARY") {
                                  return cd.code + " [" + cd.type + "]";
                                } else {
                                  return cd.code;
                                }
                          })
                          .value()
                          .join("; ");
                });
            });
          },
          makeFacetFetcher: function(facetName, name) {
            var nm = name;
            if (!nm) {
              nm = facetName + "[FACET]"
            }
            return g_api.FetcherMaker.make(nm, function(simpleSub) {
              return SubstanceFinder.getDisplayNameMatches(simpleSub["_name"])
                             .andThen(function(res){
                                var facets=res["facets"];
                                   return _.chain(facets)
                                           .filter(function(fv){
                                              return fv.name == facetName;
                                            })
                                           .map(function(fv){
                                                return _.chain(fv["values"])
                                                        .map(function(fval){
                                                              return fval["label"];
                                                            })
                                                        .value()
                                                        .join("|");
                                            })
                                           .value().join("");                               
                                });
            
            });
          }
        };

        g_api.FetcherRegistry = {
          fetchMap: {},
          getFetcher: function(name) {
            var ret = g_api.FetcherRegistry.fetchMap[name];
            return ret;
          },
          addFetcher: function(fetcher) {
            g_api.FetcherRegistry.fetchMap[fetcher.name] = fetcher;
            g_api.FetcherRegistry.fetchers.push(fetcher);
            return g_api.FetcherRegistry;
          },
          fetchers: [],
          //Actually accumulates into a master fetcher 
          getFetchers: function(list) {
            var retlist = _.map(list, function(f) {
              return g_api.FetcherRegistry.getFetcher(f);
            });
            return g_api.FetcherRegistry.joinFetchers(retlist);
          },
          joinFetchers: function(retlist) {
            return g_api.FetcherMaker.make("Custom", function(simpleSub) {
              var proms = _.map(retlist, function(r) {
                return r.fetcher(simpleSub);
              });
              var promNames = _.map(retlist, function(r) {
                return r.name;
              });


	      return g_api.JPromise.of(function (callback){
			g_api.JPromise.join(proms)
		          .get(function(array){
				callback(array,promNames);
			   });
	      });
            });
          },
          getFetcherTags: function(){
            var allTags=[];
            _.chain(g_api.FetcherRegistry.fetchers)
                 .map(function(f){return f.tags;})
                 .forEach(function(tgs){
                _.forEach(tgs,function(t){allTags.push(t);});
             }).value();
            return _.uniq(allTags);
          },
          getFetchersWithTag: function(tag){
            return _.chain(g_api.FetcherRegistry.fetchers)
                 .filter(function(f){return _.indexOf(f.tags,tag)>=0;})
                 .value();
          },
          getFetchersWithNoTag: function(){
            return _.chain(g_api.FetcherRegistry.fetchers)
                 .filter(function(f){return f.tags.length===0;})
                 .value();
          }
        };

        var UUID = {
          randomUUID: function() {
            return UUID.s4() + UUID.s4() + '-' + UUID.s4() + '-' + UUID.s4() + '-' +
              UUID.s4() + '-' + UUID.s4() + UUID.s4() + UUID.s4();
          },
          s4: function() {
            return Math.floor((1 + Math.random()) * 0x10000)
              .toString(16)
              .substring(1);
          },
          isUUID: function(uuid) {
            if ((uuid + "").match(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/)) {
              return true;
            }
            return false;
          }
        };

        g_api.UUID=UUID;

        g_api.Request = {
              builder: function() {
                var rq = {
                  _method: "GET"
                };
                rq.url = function(url) {
                  rq._url = url;
                  return rq;
                };
                rq.method = function(method) {
                  rq._method = method;
                  return rq;
                };
                rq.queryStringData = function(q) {
                  rq._q = q;
                  return rq;
                };
                rq.body = function(b) {
                  rq._b = b;
                  return rq;
                };
		rq.execute = function(){
			return g_api.httpProcess(rq);
		}
                return rq;
              }
            };

        //********************************
        //Models
        //********************************

        var CommonData = {
          builder: function() {
            var data = {};

            //should be set
            data._path = "";
            data._type = "";

            //default values
            data.uuid = UUID.randomUUID();
            data.references = [];
            data.access = [];
            data._references = [];

            data.build = function() {
              var d = JSON.parse(JSON.stringify(data));
              g_api.gUtil.removeKeysLike(d, /^_/);
              return d;
            };

            data.setAccess = function(list) {
              data.access = list;
              return data;
            };

            data.setProtected = function() {
              data.access = ["protected"];
              return data;
            };

            data.setPublic = function(pub) {
              if (pub) {
                return data;
              }
              return data.setProtected();
            };

            data.setDeprecated = function(d) {
              if (d) {
                data.deprecated = true;
              } else {
                data.deprecated = false;
              }
              return data;
            };

            data.addReference = function(r) {
              if (UUID.isUUID(r)) {
                data.addReferenceUUID(r);
              } else {
                if (r._type === "reference") {
                  data._references.push(r);
                  data.addReferenceUUID(r.uuid);
                } else {
                  var ref = _.merge(Reference.builder(), r);
                  data._references.push(ref);
                  data.addReferenceUUID(ref.uuid);
                }
              }
              return data;
            };

            data.addReferenceUUID = function(ruuid) {
              data.references.push(ruuid);
              return data;
            };

            data.addToPatch = function(patch) {
              patch = patch.add(data._path, data.build());
              _.forEach(data._references, function(r) {
                patch = patch.add("/references/-", r.build());
              });
              return patch;
            };

            data.mix = function(source) {
              _.merge(data, source);
              return data;
            };

            return data;
          }
        };

        var Name = {
          builder: function() {
            var name = CommonData.builder();
            name._type = "name";
            name._path = "/names/-";

            name.type = "cn";
            name.setName = function(nm) {
              name.name = nm;
              return name;
            };
            name.setType = function(type) {
              name.type = type;
              return name;
            };
            name.setLanguages = function(lng) {
              name.languages = lng;
              return name;
            };
            name.setDomains = function(dmns) {
              name.domains = dmns;
              return name;
            };
            name.setNameOrgs = function(orgs) {
              name.nameOrgs = orgs;
              return name;
            };


            return name;
          }
        };

        var Reference = {
          builder: function() {
            var ref = CommonData.builder();
            ref._type = "reference";
            ref._path = "references/-";

            ref.setCitation = function(cit) {
              ref.citation = cit;
              return ref;
            }
            ref.setUrl = function(url) {
              ref.url = url;
              return ref;
            }
            ref.setDocType = function(typ) {
              ref.docType = typ;
              return ref;
            }
            ref.setPublicDomain = function(pd) {
              ref.publicDomain = pd;
              return ref;
            }

            //@Override
            var oldBuild = ref.build;
            ref.build = function() {
              var d = oldBuild();
              delete d.references;
              return d;
            }
            return ref;
          }
        };

        g_api.CommonData=CommonData;
        g_api.Name=Name;
        g_api.Reference=Reference;


        var Scripts = {
          scriptMap: {},
          addScript: function(s) {
            Scripts.scriptMap[s.name] = s;
            return Scripts;
          },
          get: function(nm) {
            return Scripts.scriptMap[nm];
          },
          all: function() {
            return _.chain(_.keys(Scripts.scriptMap))
              .map(function(s) {
                return Scripts.scriptMap[s];
              })
              .value();
          }
        };

        var Script = {
          builder: function() {
            var scr = {};
            scr.argMap = {};
            scr.arguments = [];
            scr.addArgument = function(arg) {
              if (arg._type !== "argument") {
                arg = Argument.builder().mix(arg);
              }
              scr.arguments.push(arg);
              scr.argMap[arg.getKey()] = arg;
              return scr;
            };
            scr.setKey = function(key) {
              scr.key = key;
              return scr;
            };
            scr.setName = function(name) {
              scr.name = name;
              return scr;
            };
            scr.setDescription = function(desc) {
              scr.description = desc;
              return scr;
            };
            scr.mix = function(sc) {
              _.merge(scr, sc);
              _.forEach(scr.arguments, function(a) {
                scr.argMap[a.getKey()] = a;
              });
              return scr;
            };
            scr.getArgument = function(narg) {
              return scr.argMap[narg];
            };
            scr.getArgumentByName = function(narg) {
              var l = _.filter(scr.arguments,function(a){return a.name===narg});
              if(l.length==0)return undefined;
              return l[0];
            };
            scr.hasArgumentByName = function(narg) {
              return !(typeof scr.getArgumentByName(narg)==="undefined");
            };
            scr.hasArgument = function(narg) {
              return !(typeof scr.getArgument(narg)==="undefined");
            };

            scr.setExecutor = function(exec) {
              scr.executor = exec;
              return scr;
            };
            scr.useFor = function(cb){
            cb(scr);
            };

            //should return a promise
            //takes a 
            scr.execute = function(vals) {
              return g_api.JPromise.of(function(cb) {
                var ret = scr.executor(vals);
                if (ret && ret._promise) {
                  ret.get(cb);
                } else {
                  cb(ret);
                }
              });

            };
            scr.runner = function() {
              var cargs = {
                args: {}
              };
              cargs.setValue = function(key, value) {
                var darg = scr.getArgument(key);
                if (!darg) {
                  throw "No such argument '" + key + "' in script '" + scr.name + "'";
                }
                cargs.args[key] = Argument.builder().mix(scr.getArgument(key)).setValue(value);
                return cargs;
              };
                    cargs.setValues = function(kvpairs){
                  _.forEach(_.keys(kvpairs), function(k){
                                cargs.setValue(k,kvpairs[k]);
                            });
                  return cargs;
              };
              cargs.getArguments = function(){
                      var ret=[];
                      _.forEach(_.keys(cargs.args), function(k){
                                ret.push(cargs.args[k]);
                            });
                  return ret;
              };
              _.forEach(scr.arguments, function(a) {
                cargs.args[a.getKey()] = a;
              });
              cargs.execute = function() {
                return scr.execute(cargs.args);
              };
              return cargs;
            };

            return scr;
          }
        };

        var Argument = {
          builder: function() {
            var arg = {};
            arg._type = "argument";
            //name of the argument
            arg.setName = function(nm) {
              arg.name = nm;
              return arg;
            };
            arg.mix = function(ar) {
              return _.merge(arg, ar);
            };
            arg.setRequired = function(r) {
              arg.required = r;
              return arg;
            };
            arg.getKey = function(){
              if(arg.key){
            return arg.key;
              }
              return arg.name;
            };

            arg.isRequired = function(r) {
              if (arg.required) return true;
              return (typeof arg.default) === "undefined";
            };

            arg.setDescription = function(des) {
              arg.description = des;
              return arg;
            };
            arg.setType = function(type) {
              arg.type = type;
              return arg;
            };
            arg.setValue = function(value) {
              arg.value = value;
              return arg;
            };
            arg.setDefault = function(def) {
              arg.default = def;
              return arg;
            };
            arg.getValue = function() {
              if (arg.value) {
                return arg.value;
              } else {
                return arg.default;
              }
            };
            return arg;
          }
        };
        g_api.Scripts=Scripts;
        g_api.Script=Script;
        g_api.Argument=Argument;

        GSRSAPI.initialize(g_api);

        return g_api;
    },
    initialize: function(g_api){
      _.chain(GSRSAPI.extensions)
       .forEach(function(ex){
            ex.init(g_api);
        });
    },
    addExtension:function(ext){
        GSRSAPI.extensions.push(ext);
    },
    extensions:[] 
}





//Global Helpers
//For use in legacy code (should refactor)
var GGlob=GSRSAPI.builder();
var GlobalSettings = GGlob.GlobalSettings;
var getListener= GGlob.getListener;
var JPromise = GGlob.JPromise;
var gUtil = GGlob.gUtil;
var ResourceFinder =GGlob.ResourceFinder;
var SubstanceFinder=GGlob.SubstanceFinder;
var ReferenceFinder=GGlob.ReferenceFinder;
var SearchRequest  =GGlob.SearchRequest;
var SubstanceBuilder = GGlob.SubstanceBuilder;
var Patch = GGlob.Patch;
var ResolveWorker = GGlob.ResolveWorker;
var FetcherMaker = GGlob.FetcherMaker;
var FetcherRegistry = GGlob.FetcherRegistry;
var UUID = GGlob.UUID;
var Request = GGlob.Request;

//TODO: Finish this
var Validation = {
  builder: function() {
    var v = {};
  }
}


//********************************
//Models
//********************************

var CommonData = GGlob.CommonData;
var Name = GGlob.Name;
var Reference = GGlob.Reference;
var Debug = {}


//I don't like this yet
//it's here as a quick and dirty way to make
//VBA have a simple recipe for doing predefined things
var Scripts = GGlob.Scripts;
var Script = GGlob.Script;
var Argument = GGlob.Argument;




//********************************
//Fetchers
//********************************

FetcherRegistry.addFetcher(
  FetcherMaker.make("Active Moiety PT", function(simpleSub) {
    return simpleSub.fetch("relationships")
      .andThen(function(r) {
        return _.chain(r)
         .filter({type:"ACTIVE MOIETY"})
         .map(function(ro){return ro.relatedSubstance.refPname;})
         .value()
         .join("|");
      });
  }).addTag("Substance")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Active Moiety ID", function(simpleSub) {
    return simpleSub.fetch("relationships")
      .andThen(function(r) {
        return _.chain(r)
         .filter({type:"ACTIVE MOIETY"})
         .map(function(ro){return ro.relatedSubstance.approvalID;})
         .value()
         .join("|");
      });
  }).addTag("Substance")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Smiles", function(simpleSub) {
    return simpleSub.fetch("structure/smiles");
  }).addTag("Chemical")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("InChIKey", function(simpleSub) {
    return simpleSub.fetch("structure!$inchikey()")
                    .andThen(function(ik){
                        var iks=ik.split("=");
                        if(iks.length>1){
                            return iks[1];
                        }else{
                            return null;
                        }
                    });
  }).addTag("Chemical")
);


FetcherRegistry.addFetcher(
  FetcherMaker.make("Exact Test", function(simpleSub) {
    return simpleSub.fetch("structure/smiles")
                    .andThen(function(smi){
                        return SubstanceFinder.getExactStructureMatches(smi)
                                          .andThen(function(s){
                                            return _.chain(s.content)
                                                    .map(function(o){return o._name;})
                                                    .value().join("|");
                                          });
                    });
                    
  }).addTag("Tests")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Image URL", function(simpleSub) {
    var base= GlobalSettings.getBaseURL().replace(/api.*/g,"");
    var imgurl = base + "img/" + simpleSub.uuid + ".png?size=300";
    return JPromise.ofScalar(imgurl);
  })
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Protein Sequence", function(simpleSub) {
    return simpleSub.fetch("protein/subunits!(sequence)!join(;)");
  }).addTag("Protein")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("UUID", function(simpleSub) {
    return JPromise.ofScalar(simpleSub.uuid);
  }).addTag("Identifiers")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Lychi", function(simpleSub) {
    return simpleSub.fetch("structure/properties(label:LyChI_L4)($0)/term");
  }).addTag("Chemical")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Substance Class", function(simpleSub) {
    return JPromise.ofScalar(simpleSub.substanceClass);
  }).addTag("Substance")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Record Access", function(simpleSub) {
    return JPromise.ofScalar(simpleSub.access.join(";"));
  }).addTag("Record")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("All Names", function(simpleSub) {

    return simpleSub.fetch("names!(name)!join(|)").andThen(function(n) {
      return n.replace(/%7C/g, "|");
    });
  }).addTag("Substance")
);

FetcherRegistry.addFetcher(FetcherMaker.makeCodeFetcher("BDNUM").addTag("Identifiers"))
  .addFetcher(FetcherMaker.makeCodeFetcher("WHO-ATC", "ATC Code").addTag("Substance"))
  .addFetcher(FetcherMaker.makeCodeFetcher("CAS", "CAS Numbers").addTag("Identifiers"))
  .addFetcher(FetcherMaker.makeCodeFetcher("EVMPD", "EVMPD Code").addTag("Identifiers"))
  .addFetcher(FetcherMaker.makeFacetFetcher("INN Stem").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Approval Year").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Primary Target").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Condition").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("ATC Level 1").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("NPC Dataset").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Development Status").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Substance Form").addTag("Facets"))
  .addFetcher(FetcherMaker.makeFacetFetcher("Pharmacology").addTag("Facets"));

FetcherRegistry.addFetcher(FetcherMaker.makeScalarFetcher("_name", "Preferred Term").addTag("Substance"))
  .addFetcher(FetcherMaker.makeScalarFetcher("_approvalIDDisplay", "Approval ID (UNII)").addTag("Identifiers"))
  .addFetcher(FetcherMaker.makeScalarFetcher("createdBy", "Created By").addTag("Record"))
  .addFetcher(FetcherMaker.makeScalarFetcher("created", "Created Date").andThen(gUtil.toDate).addTag("Record"))
  .addFetcher(FetcherMaker.makeScalarFetcher("lastEditedBy", "Last Edited By").addTag("Record"))
  .addFetcher(FetcherMaker.makeScalarFetcher("lastEdited", "Last Edited Date").andThen(gUtil.toDate).addTag("Record"))
  .addFetcher(FetcherMaker.makeScalarFetcher("version", "Version").addTag("Record"))
  .addFetcher(FetcherMaker.makeAPIFetcher("structure/formula", "Molecular Formula").addTag("Chemical"))
  .addFetcher(FetcherMaker.makeAPIFetcher("structure/mwt", "Molecular Weight").addTag("Chemical"));
  
FetcherRegistry.addFetcher(
  FetcherMaker.make("Tags", function(simpleSub) {
    return simpleSub.fetch("tags!(term)!distinct()!sort()!join(|)").andThen(function(n) {
      return n.replace(/%7C/g, "|");
    });
  }).addTag("Record")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Mixture Component UNII", function(simpleSub) {
    return simpleSub.fetch("/mixture/components!(substance/approvalID)!join(|)").andThen(function(n) {
      return n.replace(/%7C/g, "|");
    });
  }).addTag("Mixture")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Mixture Component PT", function(simpleSub) {
    return simpleSub.fetch("/mixture/components!(substance/refPname)!join(|)").andThen(function(n) {
      return n.replace(/%7C/g, "|");
    });
  }).addTag("Mixture")
);



FetcherRegistry.addFetcher(
  FetcherMaker.make("WHO-ATC", function(simpleSub) {
    return simpleSub.fetch("codes(codeSystem:WHO-ATC)").andThen(function(n) {
      return _.chain(n)
              .map(function(c){
			return c.comments;
		})
	      .value().join(";");
    });
  }).addTag("Classification")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("WHO-VATC", function(simpleSub) {
    return simpleSub.fetch("codes(codeSystem:WHO-VATC)").andThen(function(n) {
      return _.chain(n)
              .map(function(c){
			return c.comments;
		})
	      .value().join(";");
    });
  }).addTag("Classification")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("LIVERTOX", function(simpleSub) {
    return simpleSub.fetch("codes(codeSystem:LIVERTOX)").andThen(function(n) {
      return _.chain(n)
              .map(function(c){
			return c.comments;
		})
	      .value().join(";");
    });
  }).addTag("Classification")
);


FetcherRegistry.addFetcher(
  FetcherMaker.make("Equivalance Factor", function(simpleSub) {
  
    return simpleSub.fetch("structure/mwt").andThen(function(mwt) {
      
      return simpleSub.fetch("relationships")
                      .andThen(function(r) {
                            var amuuid=_.chain(r)
                                 .filter({type:"ACTIVE MOIETY"})
                                 .map(function(ro){return ro.relatedSubstance.refuuid;})
                                 .value()[0];
                            return SubstanceFinder.get(amuuid)
                                           .andThen(function(amsub){
                                                return amsub.fetch("structure/mwt").andThen(function(mwt2){
                                                    return mwt/mwt2;
                                                });
                                           });
                      });
    });
  }).addTag("Chemical")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Latin Binomial", function(simpleSub) {
    return simpleSub.fetch("structurallyDiverse!$select(organismGenus,organismSpecies)!join(%20)").andThen(function(n) {
      return n.replace(/%20/g, " ");
    });
  }).addTag("Structurally Diverse")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Author", function(simpleSub) {
    return simpleSub.fetch("structurallyDiverse/organismAuthor");
  }).addTag("Structurally Diverse")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Stitcher Description", function(simpleSub) {
    
     return GGlob.JPromise.of(function(cb) {
                getJson("https://stitcher.ncats.io/api/stitches/latest/" + simpleSub.approvalID, function(dat){
                   var desc=dat.sgroup.properties["CompoundDescription"];
                   if(desc){
                       var ret=_.chain(desc)
                        .map(function(d){return d.value})
                        .value()
                        .join("|");
                       cb(ret);
                   }else{
                       cb("");
                   }
                });
              });
    
  }).addTag("Stitcher")
);


FetcherRegistry.addFetcher(
  FetcherMaker.make("Stitcher OB approval", function(simpleSub) {
    
     return GGlob.JPromise.of(function(cb) {
                getJson("https://stitcher.ncats.io/api/stitches/latest/" + simpleSub.approvalID, function(dat){
                   var desc=dat["events"];
                   if(desc){
                       var ret=_.chain(desc)
                        .filter(function(d){if(d.date)return true;})
                        .filter(function(d){if(d.source==="approvalYears.txt")return true;})
                        .map(function(d){return d.date + "[" + d.kind + "]{" + d.source + "}";})
                        .value()
                        .join("|");
                       cb(ret);
                   }else{
                       cb("");
                   }
                });
              });
    
  }).addTag("Stitcher")
);


FetcherRegistry.addFetcher(
  FetcherMaker.make("Stitcher Pharm Manu approval", function(simpleSub) {
    
     return GGlob.JPromise.of(function(cb) {
                getJson("https://stitcher.ncats.io/api/stitches/latest/" + simpleSub.approvalID, function(dat){
                   var desc=dat["events"];
                   if(desc){
                       var ret=_.chain(desc)
                        .filter(function(d){if(d.date)return true;})
                        .filter(function(d){return (d.kind==="ApprovalRx")})
                        .filter(function(d){if(d.source==="PharmManuEncycl3rdEd.json")return true;})
                        .map(function(d){return d.date + "[" + d.kind + "]{" + d.source + "}";})
                        .value()
                        .join("|");
                       cb(ret);
                   }else{
                       cb("");
                   }
                });
              });
    
  }).addTag("Stitcher")
);


FetcherRegistry.addFetcher(
  FetcherMaker.make("Part", function(simpleSub) {
    return simpleSub.fetch("structurallyDiverse/part!(term)!join(|)").andThen(function(n) {
      return n.replace(/%7C/g, "|");
    });
  }).addTag("Structurally Diverse")
);



FetcherRegistry.addFetcher(
  FetcherMaker.make("Stereo Type", function(simpleSub) {
    return simpleSub.fetch("structure/stereoChemistry");
  }).addTag("Chemical")
);

FetcherRegistry.addFetcher(
  FetcherMaker.make("Record URL", function(simpleSub) {
    return JPromise.ofScalar(GlobalSettings.getHomeURL() + "substance/" + simpleSub.uuid);
  }).addTag("Record")
);


//If these names are directly registered
FetcherRegistry.addFetcher(
  FetcherMaker.make("Bracket Terms", function(simpleSub) {
    return simpleSub.fetch("names!(name)").andThen(function(n) {
      return _.chain(n)
              .filter(function(n1) {
                return n1.match(/\[.*\]/g);
              })
              .value().join("|");
    });
  }).addTag("Substance")
);

//********************************
//Scripts
//********************************

Script.builder().mix({name: "Add Name", description: "Adds a name to a substance record"})
  .addArgument({
    "key": "uuid", name: "UUID", description:"UUID of the substance record", required:true
  })
  .addArgument({
    "key": "name", name: "NAME", description:"Name text of the new name", required:true
  })
  .addArgument({
    "key": "nameType", name: "NAME TYPE", description:"Name text of the new name", default:"cn", required: false
  })
  .addArgument({
    "key": "public", name: "PD", description:"Public Domain status of the name (sets access for reference as well)", default:false, required: false
  })
  .addArgument({
    "key": "referenceType", name: "REFERENCE TYPE", description:"Type of reference", default:"SYSTEM", required: false
  })
  .addArgument({
    "key": "referenceCitation", name: "REFERENCE CITATION", description:"Citation text for reference", required:true
  })
  .addArgument({
    "key": "referenceUrl", name: "REFERENCE URL", description:"URL for the reference", required:false
  })
 .addArgument({
    "key": "changeReason", name: "CHANGE REASON", default: "Added Name", description:"Text for the record change", required: false
  })
  .setExecutor(function(args) {
    var uuid = args.uuid.getValue();
    var name = args.name.getValue();
    var nameType = args.nameType.getValue();
    var public = args.public.getValue();
    var referenceType = args.referenceType.getValue();
    var referenceCitation = args.referenceCitation.getValue();
    var referenceUrl = args.referenceUrl.getValue();

    var reference = Reference.builder().mix({citation:referenceCitation, docType:referenceType});
    if (referenceUrl && referenceUrl.length > 0) {
      reference = reference.setUrl(referenceUrl);
    }
    if (public && public === "true" || public === true || public === "Y") {
      reference.setPublic(true);
      reference.setPublicDomain(true);
    } else {
      reference.setPublic(false);
      reference.setPublicDomain(false);
    }

    var name = Name.builder().setName(name)
      .setType(nameType)
      .setPublic(public)
      .addReference(reference);

    return SubstanceFinder.get(uuid)
      .andThen(function(s) {
        return s.patch().addData(name)
            .add("/changeReason",args.changeReason.getValue())
            .apply()
            .andThen(_.identity);
      });
  })
  .useFor(function(s){Scripts.addScript(s);});





Script.builder().mix({name: "Add Code", description: "Adds a code to a substance record"})
  .addArgument({
    "key": "uuid", name: "UUID", description:"UUID of the substance record", required:true
  })
  .addArgument({
    "key": "code", name: "CODE", description:"Code text of the new code", required:true
  })
  .addArgument({
    "key": "codeSystem", name: "CODE SYSTEM", description:"Code system of the new code", required:true
  })
  .addArgument({
    "key": "codeType", name: "CODE TYPE", description:"Code type of code. For instance, whether it's a primary code", default:"PRIMARY", required: false
  })
  .addArgument({
    "key": "url", name: "CODE URL", description:"URL to evaluate this code (this is distinct from the reference URL)", required:false
  })
  .addArgument({
    "key": "public", name: "PD", description:"Public Domain status of the code (sets access for reference as well)", default:false, required: false
  })
  .addArgument({
    "key": "referenceType", name: "REFERENCE TYPE", description:"Type of reference", default:"SYSTEM", required: false
  })
  .addArgument({
    "key": "referenceCitation", name: "REFERENCE CITATION", description:"Citation text for reference", required:true
  })
  .addArgument({
    "key": "referenceUrl", name: "REFERENCE URL", description:"URL for the reference", required:false
  })
  .addArgument({
    "key": "changeReason", name: "CHANGE REASON", default: "Added Code", description:"Text for the record change", required: false
  })
  .setExecutor(function(args) {
    var uuid = args.uuid.getValue();
    var code = args.code.getValue();
    var codeType = args.codeType.getValue();
    var codeSystem = args.codeSystem.getValue();
    var url = args.url.getValue();
    var public = args.public.getValue();
    var referenceType = args.referenceType.getValue();
    var referenceCitation = args.referenceCitation.getValue();
    var referenceUrl = args.referenceUrl.getValue();

    var reference = Reference.builder().mix({citation:referenceCitation, docType:referenceType});
    if (referenceUrl && referenceUrl.length > 0) {
      reference = reference.setUrl(referenceUrl);
    }
    if (public && public === "true" || public === true || public === "Y") {
      reference.setPublic(true);
      reference.setPublicDomain(true);
    } else {
      reference.setPublic(false);
      reference.setPublicDomain(false);
    }

    var code = Code.builder().setCode(code)
      .setType(codeType)
      .setCodeSystem(codeSystem)
      .setPublic(public)
      .addReference(reference);

    if(url){
      code.setUrl(url)
    }

    return SubstanceFinder.get(uuid)
      .andThen(function(s) {
        return s.patch().addData(code)
            .add("/changeReason",args.changeReason.getValue())
            .apply()
            .andThen(_.identity);
      });
  })
  .useFor(function(s){Scripts.addScript(s);});



















//cache of results
var cresults = {
  "getItem": function(v) {
    return this[v];
  },
  "popItem": function(v) {
    var ret = this[v];
    delete this[v];
    return ret;
  }
}


$(document).ready(function() {
  var htmltemplate=$("#fetcherTemplate").html();
  _.chain(FetcherRegistry.getFetcherTags())
   .filter(function(t){return (t !== "Tests")})
   .forEach(function (tag){
	var fetchers=FetcherRegistry.getFetchersWithTag(tag);
	var nhtml=_.chain(fetchers)
         .map("name")
         .map(function(n){
		return htmltemplate.replace(/\$name\$/g,n);
	 })
         .value().join("\n");
	$("#outputSettings").append("<div><h3>" + tag + "</h3>" + nhtml + "</div>");
    }).value();
   var nhtml=_.chain(FetcherRegistry.getFetchersWithNoTag())
		   .map("name")
		   .map(function(n){
			return htmltemplate.replace(/\$name\$/g,n);
		    }).value().join("\n");
   $("#outputSettings").append("<div><h3>Others</h3>" + nhtml + "</div>");
});
function showPreview(runner){
	$("#scriptArguments").html("");
  _.forEach(runner.getArguments(), function(a){
			var val=a.getValue();
			if(!val){
			    val="";
			}
			var html= $("#argTemplate").html()
						   .replace(/\$arg\$/g,a.name)
                                                   .replace(/\$value\$/g,val);
			if(a.isRequired()){
				html=html.replace(/\$req\$/g,"*");
			}else{
				html=html.replace(/\$req\$/g,"");
			}
                                                   
			
   		        $("#scriptArguments").append(html);
		});
}
function showScripts(){
  $("#scriptlist").html("");
  _.forEach(Scripts.all(), function(script){
  			$("#scriptlist").append("<option value='" + script.name + "'>" + script.name + "</option>");
  	   });
  $("#scriptlist").change(function (){
		var script=Scripts.get($("#scriptlist").val());
		$("#scriptdetails").html(script.description);
	});
}
function setMode(m){
  $("#outputSettings").hide();
  $("#scriptArguments").hide();
  $("#showScripts").hide();
  
  if(m==="resolver"){
        $("#outputSettings").show();
  }else if(m==="showScripts"){
        $("#showScripts").show();
        showScripts();
  }else{ //resolver
        $("#scriptArguments").show();
  }
}

</script>
</body>
